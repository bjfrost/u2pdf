#!/usr/bin/env python
# -*- coding: utf-8 -*-
import cairo
import pango
import pangocairo
import sys
import codecs
import argparse
import os
import time
import re


"""
\file		u2pdf

\brief		produce listing of a file as a PDF file.

description:

  Uses python with cairo and pango to produce the PDF
  file.  It assumes that the font provided is a monospace
  font otherwise, it may produce strange results.

  Options:

    Option       |  Description
    -------------|-----------------------------------------------
    -o OUTFILE   |  Output file
    -overwrite   |  Continue if output file exists
    -paper NAME  |  Page type: 'letter', 'legal', 'a4', ...
    -portrait    |  Portrait pages
    -landscape   |  Landscape pages
    -2up         |  Print 2 pages per physical page in landscape
    -number      |  Number lines of input file
    -tabs STOPS  |  The locations of tab stops
    -borders     |  Draw borders around page (default)
    -noborders   |  Do not draw borders around pages
    -headings    |  Print page headings (default)
    -noheadings  |  Do not print page headings
    -font NAME   |  Name of font to use
    -fs FSZ      |  Integer font size in points
    -lineskip    |  Additional space between lines in points
    -verbose     |  Print debugging information on stdout

  Printing

    Printing each page involves the use of the following global
    variables:

       Variable   |  Description
       -----------|--------------------------------------------------
       lineno     |  Current line number from file
       linepos    |  Current vertical position in page
       lineskip   |  Amount linepos is increased for each output line
       pageno     |  The current page number
       subpageno  |  The current sub-page number if printing n-up
       subpage    |  The current sub-page on page
       umargin    |  The location of the first line of output on a page
       maxlinepos |  The first location beyond the last listing line

    The newOutputLine function is responsible for printing a line of
    output at the current linepos.  It calls the newOutputPage
    function when the current page is full (which may call
    newOutputLine if headings are being printed).

"""

#   **************************************************
#   *
#   *              Global Variables
#   *
#   **************************************************

"""
\var	MyName

\brief  Name of this program used in error messages
"""
MyName   =  os.path.basename (__file__)


"""
\var 	papersizes

\brief	Provides the size in points of various named paper.

description:

  This dictionary is used to determine if the '-paper'
  command line switch has provided a name for which
  this program has size information.  The size is
  provided in portrait mode and will be swapped to
  produce the landscape page size.

"""
papersizes = {

    # Name          Size
    # ==========  ===========

    'letter':     (612,  792),
    'legal':      (612, 1008),
    'executive':  (540,  720),
    'folio':      (612,  936),
    'a4':         (595,  842),
    'a5':         (420,  595),
    'a6':         (298,  420),
    'b5':         (516,  729),
    'b6':         (354,  499)
}


"""
\var	outfile

\brief	Name of the output PDF file.

description:

  This name comes from the '-o' command line switch
  or it is computed from the input file name.  The
  actual value is filled in later after processing
  the command line.

"""
outfile    = ''


"""
\var	filename

\brief	Name of the input file whose contents are displayed in PDF file.

description:

  This name comes from the command line where it is
  the FILENAME in the usage.  The actual value is
  filled in later after processing the command line.

"""
filename   = ''               # os.path.expanduser (options.filename)


"""
\var	page

\brief  size of target paper in points: (width, height)
"""
page       = (0, 0)            #  papersizes[options.paper]


"""
\var	wrapped

\brief	count of number of lines that have wrapped
"""
wrapped    = 0


"""
\var	lineno

\brief	the line number of the input file being processed.
"""
lineno     = 0


"""
\var	pageno

\brief	the current physical page number
"""
pageno     = 1


"""
\var	totalpages

\brief	the total number of pages that will be printed
"""
totalpages    = 0


"""
\var	totalsubpages

\brief	the total number subpages that will be printed
"""
totalsubpages = 0


"""
\var	subpage

\brief	the subpage within the current physical page

description:

  This value indicates the subpage number on the
  current page.  When the page is finished, this
  value goes back to 0.

"""
subpage    = 0


"""
\var	subpageno

\brief	the total number of subpages that have been printed.
"""
subpageno  = 0


"""
\var	pageready

\brief	page borders and headings are present.
"""
pageready  = False


"""
\var	umargin

\brief	The upper margin for the page.

description:

  The entire page is not normally printable and this value
  is used to indicate the physical border on top of the
  page that will not be printed.

  This value is also used for the bottom border.
"""
umargin    = 30


"""
\var	linepos

\brief	the current vertical page location in points
"""
linepos    = umargin


"""
\var	lmargin

\brief  The left margin of the page.

description:

  The entire page is not printable, this value indicates
  the physical left border on the page that will not be
  printed.

  This value is also used for the left border.
"""
lmargin    = 30


"""
\var	fontsize

\brief	the size in points of the font.
"""
fontsize   = 0            # options.fs if options.fs > 0 else 10


"""
\var	fontname

\brief	the name of the font used to display the filename.
"""
fontname   = ''           # options.font


"""
\var	datentime

\brief	the date and time displayed in page headings.
"""
datentime  = time.strftime ("%b %d, %Y %H:%M")


"""
\var	pg2upskip

\brief	the additional lineskip used to display physical page numbers

description:

  Used in '-2up' mode to display the physical page number below
  the page borders on the bottom right corner of the page.
"""
pg2upskip  = 3       # used in setPageNumber for 2up page number skip


"""
\var	pg2upsep

\brief  the white space between sub-pages on a physical page.
"""
pg2upsep   = 14      # white space between subpages


"""
\var	halpha

\brief	alpha value for greyed out heading (0...1) (white...black)
"""
halpha     = 0.15    # alpha value for greyed out heading  0=white, 1=black


"""
\var	chwidth

\brief	calculated character width

description:

  This is an average of the space required for 100 instances
  of the canonical "wide" character.

"""
chwidth    = 1       # filled in by getMaxCPL


"""
\var	basename

\brief	base name of the input file used in headings.

description:

  Filled in later based upon the command line.
"""
basename   = ''


"""
\var	fullname

\brief	full path name of the input file.

description:

  Filled in later based upon the command line.
"""
fullname   = ''


"""
\var	heading

\brief	page heading line.

description:

  Filled in later based upon the command line and target
  paper size.  The heading contains the date and time,
  base file name being displayed and the page number.

"""
heading    = ""


"""
\var	lineskip

\brief	the increase in the Y-coordinate value for one output line.

description:

  This value depends upon the font and the size of the font.
  The actual value is computed after that information is
  known.

"""
lineskip   = 0


"""
\var	maxlinepos

\brief  the first vertical location beyond the last printable line.

description:

   Lines of output are generated until linepos becomes
   greater than or equal to maxlinepos.  maxlinepos is
   takes the following factors into account:

   - lineskip:  the amount by which every line increases the
                vertical page location.

   - page[1]:   the total imaging height of the page

   - umargin:   the space at the top and bottom of the page to
                leave blank.

   1. The first step is to compute the amount of vertical space
      that could be used:

              page[1] - (2 * umargin)

   2. Then this space is divided by the lineskip value to obtain
      the number of lines that fit in the vertical space.
      Truncated to an integer this reflects the actual number of
      lines per page that fit the vertical area.

   3.  The actual number of lines per page is then multiplied by
       lineskip to obtain the vertical distance that will be
       printed.

   4.  Adding umargin takes into account the upper margin that is
       not printed.

"""
maxlinepos = 0


"""
\var	maxcolpos

\brief	the first horizontal location beyond the last printable character.

description:

  This value is computed based upon:

  - the page size

  - printing mode: -portrait, -landscape, -2up

  - the font name and size

"""
maxcolpos  = 0


#   **************************************************
#   *
#   *             Internal Functions
#   *
#   **************************************************

"""
\fn    fatalerror (parser, message)

\brief prints an error message containing program name with message and exits.

description:

  This function is the last gasp for a fatal error situation.
  An output message is displayed describing the problem followed
  by the usage information for this program.

  Finally, the program exits with code 2.

"""
def fatalerror (parser, message):
    global  MyName

    print "%s: %s" % (MyName, message)
    print ""
    parser.print_usage ()
    exit (2)


"""
\fn     printoptions (options)

\brief  displays the command line option settings.

description:

  This function is called when -verbose is in effect
  to display the result of the command line processing.

"""
def printoptions (options):
    print ""
    print options

    print ""
    print "Command Line Options:"
    print "=================================="
    print "Input:     '%s'" % options.filename
    print "Output:    '%s'" % options.o
    print "Overwrite: %d"   % options.overwrite
    print "Page Size: '%s'" % options.paper
    print "Portrait:  %d"   % options.portrait
    print "Landscape: %d"   % options.landscape
    print "2up:       %d"   % options.twoup
    print "Number:    %d"   % options.number
    print "Tabs       %d"   % options.tabs
    print "Borders:   %d"   % options.borders
    print "Headings:  %d"   % options.headings
    print "Font:      '%s'" % options.font
    print "Font size: %d"   % options.fs
    print "Line Skip: %d"   % options.lineskip
    print "Verbose:   %d"   % options.verbose
    print "=================================="
    print ""


"""
\fn	getFontStyleName (style)

\brief  Returns a string indicating the font style.
"""
def getFontStyleName (style):
    str = style.__str__ ()
    match = re.search (r'PANGO_STYLE_([A-Za-z0-9_]+)', str)
    return "<unknown>" if 0==match else match.group (1)


"""
\fn	getFontVariantName (variant)

\brief	Returns a string indicating the font variant.
"""
def getFontVariantName (variant):
    str = variant.__str__ ()
    match = re.search (r'PANGO_VARIANT_([A-Za-z0-9_]+)', str)
    return "<unknown>" if 0==match else match.group (1)


"""
\fn	getFontWeightName (weight)

\brief	Returns a string indicating the font weight.
"""
def getFontWeightName (weight):
    str = weight.__str__ ()
    match = re.search (r'PANGO_WEIGHT_([A-Za-z0-9_]+)', str)
    return "<unknown>" if 0==match else match.group (1)


"""
\fn	printFont (font)

\brief	Displays debugging information about the font.
"""
def printFont (font):
    print "Scale:      %d" % pango.SCALE
    print "Family:     %s" % font.get_family    ()
    print "Style:      %s" % getFontStyleName   (font.get_style ())
    print "Variant:    %s" % getFontVariantName (font.get_variant ())
    print "Weight:     %s" % getFontWeightName  (font.get_weight ())
    print "Size:       %d" % font.get_size      ()


"""
\fn	setOutputFile  (parser, options)

\brief	Insures that options.o contains valid target PDF file

description:

  - The user directory is expanded.

  - if '-o' option not present, target file name is
    input source file name with '.pdf' suffix.

  - if target file already exists, verifies that the
    '-overwrite' switch was provided.

"""
def setOutputFile (parser, options):
    if len (options.o) == 0:
       sname = os.path.splitext (os.path.expanduser (options.filename))
       options.o = sname[0] + '.pdf'
    else:
       options.o = os.path.expanduser (options.o)

    if os.path.exists (options.o):
       if options.overwrite == 0:
       	  fatalerror (parser, 'File "%s" exists (use -overwrite)' % options.o)

    outfile = options.o


"""
\fn	drawPageBorders (context)

\brief  uses cairo context to draw border around current page.

description:

  The border is drawn using maxcolpos and page[1] (height)
  using the Cairo rectangle function using black ink and
  a line width of 1.

  If headings are being generated, then the first line of
  output on the page is the heading which appears shaded
  using the alpha channel.  The first line is selected
  using the Cairo rectangle function using maxcolpos
  for the width and lineskip + 4 for the height.

"""
def drawPageBorders (context):
    context.set_line_width (1)
    context.set_source_rgb (0, 0, 0)           # Black

    context.rectangle (-4, -4,
                       maxcolpos + 4,
                       maxlinepos - umargin + 5)

    context.stroke ()

    if options.headings:
        context.set_line_width (0.25)
        context.set_source_rgba (0.25, 0.25, 0.25, halpha)
        context.rectangle (-4, -4,
                           maxcolpos + 4, lineskip + 4)
        context.fill ()


"""
\fn	setPageHeadings (layout, context, pccontext)

\brief  Draw the page heading.

description:

  The page heading is simply the first line of output on
  each page.  Its appearance is shaded to distinguish the
  heading from the file contents.

  The basic heading line was generated during startup, the
  only work here is to add the page number to each page
  (or subpage).

  Note that newOutputLine is used to print the line which
  could be a problem if the page could only hold a single
  line of output.

"""
def setPageHeadings (layout, context, pccontext):
    global heading
    if options.twoup:
        strpageno = "Page %d/%d" % (subpageno + 1, totalsubpages)
    else:
        strpageno = "Page %d/%d" % (pageno, totalpages)
    plen      = len (strpageno)
    hlen      = len (heading)
    heading   = heading[0:hlen - plen] + strpageno
    newOutputLine (layout, context, pccontext, heading)


"""
\fn	setPageNumber (layout, context, pccontext)

\brief  Adds the actual page number when generating 2up output.

description:

  This function is called when the last subpage of output
  appears on the physical page.  This numbers the actual
  page below the page borders.

"""
def setPageNumber (layout, context, pccontext):
    global pageno
    global pg2upskip
    line = ("%d/%d" % (pageno, totalpages)).rjust (maxcpl)
    if options.verbose > 3:
        print "setPageNumber: maxcpl=%d" % maxcpl
    context.translate (0, pg2upskip)
    layout.set_text (line)
    context.set_source_rgb (0, 0, 0)    # Black
    pccontext.update_layout (layout)
    pccontext.show_layout   (layout)
    context.translate (0, -pg2upskip)


"""
\fn 	startPage (layout, context, pccontext)

\brief	insure that the current page has borders and headings.

description:

  This function is called prior to printing the first
  listing line on a page.  It insures that the page
  contains borders and headings if they are enabled.

"""
def startPage (layout, context, pccontext):
    global pageready
    global linepos

    pageready = True

    if options.borders:
        drawPageBorders (context)

    linepos = umargin

    if options.headings:
        setPageHeadings (layout, context, pccontext)


"""
\fn	finishOutputPage (layout, context, pccontext)

\brief	Finish current page

description:

  This function completes the generation of a page
  and resets the current translation to start at

"""
def finishOutputPage (layout, context, pccontext):
    global subpage
    global subpageno
    global pageno

    if False == pageready:
        return

    if options.twoup:
        if options.headings:

            if 0 == subpage:
                # shift over to second page location at page bottom
                context.translate (maxcolpos + pg2upsep,
                                   maxlinepos - linepos)
            else:
                # stay on second page but guarantee page bottom
                context.translate (0, maxlinepos - linepos)

            setPageNumber (layout, context, pccontext)
            context.translate (-maxcolpos - pg2upsep, umargin - maxlinepos)
            subpage    = 0
    else:
        context.translate (0, umargin - linepos)

    pageno += 1
    pccontext.show_page ()


"""
\fn	newOutputPage (layout, context, pccontext)

\brief  Finished current page and prepares to start next page.

description:

  This may not really finish the page if n-up pages are
  being printed.  In this case, the actual page output
  occurs after all subpages for the page are printed.

  In any case, the only interesting part is the handling
  of the current context translation which moves across
  the page for n-up printing when switching pages.

  When a physical page is printed, the context translation
  is updated by finishOutputPage to reflect the initial
  translation which was:  (lmargin, umargin).

"""
def newOutputPage (layout, context, pccontext):
    global pageno
    global subpage
    global subpageno
    global linepos
    global pageready

    if options.twoup:
        #  ***********************************************
        #  *              Two Up Output
        #  ***********************************************
        subpageno += 1
        if subpage:
            finishOutputPage (layout, context, pccontext)
            subpage = 0
        else:
            context.translate (maxcolpos + pg2upsep, umargin - linepos)
            subpage = 1
    else:
        #  ***********************************************
        #  *               One Up Output
        #  ***********************************************
        finishOutputPage (layout, context, pccontext)

    pageready = False


"""
\fn 	newOutputLine (layout, context, pccontext, line)

\brief  Print 'line' on current page and switch pages if necessary

description:

  The pccontext updates the layout and then shows
  the layout which ships the line to cairo where it appears
  on the page.  The translation is updated for the next
  output line position and that location is checked against
  the end of page location.

  End of page is always detected by linepos reaching the
  maxlinepos.  The newOutputPage function is used to complete
  the current page and switch and prepare the next page.

"""
def newOutputLine (layout, context, pccontext, line):
    global linepos
    global MyName
    global pageready

    if False == pageready:
        startPage (layout, context, pccontext)

    layout.set_text (line)
    context.set_source_rgb (0, 0, 0)         # Black

    if options.verbose > 3:
        s = layout.get_pixel_extents ().__str__ ()
        print "%s: %4d - text extents: %d" % (MyName, lineno, linepos)
	print "%s: pixel %s" % (MyName, s)
	print ""

    #  **********************************************
    #  *         Put Line on Page
    #  **********************************************
    pccontext.update_layout (layout)
    pccontext.show_layout   (layout)

    #  **********************************************
    #  *         Move to next line
    #  **********************************************
    context.translate (0, lineskip)

    linepos = linepos + lineskip
    if linepos >= maxlinepos:
        #  **********************************************
        #  *     Output page and Start a new page
        #  **********************************************
        newOutputPage (layout, context, pccontext)


"""
\fn	getMaxCPL (layout)

\brief  Compute character and line spacing information.

description:

  Text containing 100 APL quad symbols is displayed in order
  to determine the character spacing of this (assumed) monospaced
  font.  All bets are off if the font does not render the APL
  quad symbol or if this is not a monospaced font.

  The pixel extents for width and height of the string are
  retrieved and used to compute:

      Variable |  Description
      ---------|---------------------------------------------------
      chwidth  |  float value of a single character advance
      lineskip |  float value of single line height
      maxcpl   |  print width or maximum characters per line
      maxlpp   |  maximum number of lines per page
      chwidth  |  width of a single character (if monospace font)

"""
def getMaxCPL (layout):
    global maxcpl
    global lineskip
    global chwidth

    #      123456789*123456789*123456789*123456789*123456789*
    s  = u"⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕"
    s  = s + s

    layout.set_text (s)

    x        = layout.get_pixel_extents ()
    w        = x[1][2]
    h        = x[1][3]
    lineskip = h
    lc       = len (s)
    cw       = (float (w) / lc)
    chwidth  = cw

    if options.verbose:
        print x
        print "getMaxCPL:  X-extent=%6.2f  Y-extent=%6.2f" % (w, h)

    return int ((maxcolpos - cw + 1) / cw)


"""
\fn	initialPageSetting ()

\brief	Validates command line switches for paper selection

description:

  Insures that the '-paper' option contains the name of a valid
  paper size.

  Ensures that only one of '-portrait', '-landscape' or '-2up' was
  specified.

"""
def initialPageSetting ():

    #  *************************************************
    #  *     -paper must be one of the known sizes
    #  *************************************************

    if papersizes.has_key (options.paper) == False:
        keys = papersizes.keys ()
        keys.sort ()
        keys = keys.__str__ ()
        keys = keys[1:len(keys)-1]
        print "%s: available paper sizes are: %s" % (MyName, keys)
        fatalerror (parser, "Invalid page size: '%s'" % options.paper)

    #  *************************************************
    #  *     Detect conflicting page mode options:
    #  *************************************************

    errpage = 0
    if options.portrait != 0:
        if options.landscape != 0 or options.twoup != 0:
            errpage = 1
    else:
        if options.landscape != 0 and options.twoup != 0:
            errpage = 1

    if errpage != 0:
        optlist = ''
        if options.portrait != 0:
            optlist += ' -portrait'
        if options.landscape != 0:
            optlist += ' -landscape'
        if options.twoup != 0:
            optlist += ' -2up'
        fatalerror (parser, "conflicting options %s" % optlist)


"""
\fn	displayLayout ()

\brief	displays debugging information on how the page will be laid out.

"""
def displayLayout ():
    print ""
    print "Layout Size"
    print "==================="
    print "totalpages  %d" % totalpages
    print "totsubpages %d" % totalsubpages
    print "page:       %s" % page.__str__ ()
    print "font sz:    %d" % fontsize
    print "sz:         %s" % layout.get_size ().__str__ ()
    print "pixel sz:   %s" % layout.get_pixel_size ().__str__ ()
    print "lmargin:    %d" % lmargin
    print "umargin:    %d" % umargin
    print "lineskip:   %d" % lineskip
    print "maxlinepos: %d" % maxlinepos
    print "maxcolpos:  %d" % maxcolpos
    print "maxcpl:     %d" % maxcpl
    print "maxlpp:     %d" % maxlpp
    print "==================="
    print ""


"""
\fn	createHeadings (maxcpl, datentime, basename)

\brief	create heading for top of page

description:

  The page heading contains:

  -  the current date and time left justified

  -  the file name being printed centered

  -  the current page (or subpage) number right justified

  This can only be produced after the page layout has
  been determined.

"""
def createHeading (maxcpl, datentime, basename):
    heading = basename.center (maxcpl)
    avail   = maxcpl - len (datentime) - 2 - 12

    if avail < 8:
        fatalerror (parser, "Font size too large")

    if len (basename) > avail:
        basename = basename[0:avail]
        heading  = basename.center (maxcpl)

    heading = datentime + heading[len (datentime):]

    if options.verbose > 2:
        print "%s: datentime = '%s'" % (MyName, datentime)

    return heading


"""
\fn	expandTabs (text, tabs)

\brief	expands tabs in text string to appropriate spaces

"""
def expandTabs (text, tabs = 7):

    rs = u""

    for c in text:
        if '\t' == c:
            rs += u" "
            while ((len (rs) % tabs) != 0):
                rs += u" "
        else:
            rs += c

    return rs


"""
\fn	computeTotals (lskip, maxcpl, maxlinepos, file)

\brief	compute totalpages and totalsubpages prior to printing

description:

  This function processes the file contents and determining
  how each line will print.  As lines are printed, the essential
  parts of the algorithm needed to detect new subpages and
  new pages are used to count their number.

  When all lines have been processed, the totals are saved
  in the totalpages and toalsubpages variables.

  While various global values are accessed, no global
  variables are modified by this function.

"""
def computeTotals (lskip, maxcpl, maxlinepos, file):

    #  first some variables that are modified by sub-functions
    class cl:
        lineno       =  0         # input file line number
        linepos      =  umargin   # page line location
        subpage      =  0         # sub-page number within a page
        pageno       =  0         # page number
        subpageno    =  0         # sub-page number within listing
        wrapped      =  0         # wrapped line count

    """
    \fn		computeNewPage ()

    \brief	deals with the end of a page of ouptut

    description:

      Issues appear with generating n-up output which means
      that the end of a page may only be the end of a
      logical page.

      Reset cl.linepos to reflect the next printed output
      begins at the top of the printed area plus one line
      if headings are being displayed.

    """
    def computeNewPage ():
        if options.twoup:
            #  *     Printing two pages per page
            cl.subpageno += 1
            if cl.subpage:
                #  *  Finished second page
                cl.pageno += 1
                cl.subpage = 0
            else:
                #  *  Finished first page
                cl.subpage = 1
        else:
            #         One page per physical page
            cl.pageno += 1
        #  *          Print at top of new page
        cl.linepos = umargin
        if options.headings:
            #         Account for heading line
            cl.linepos += lineskip

    """
    \fn 	computeNewLine ()

    \brief	handle a new line being printed

    description:

      The only interesting thing here is that there must
      be a check for the end of the page and do the
      end of page processing if appropriate.
    """
    def computeNewLine ():
        cl.linepos += lineskip
        if cl.linepos >= maxlinepos:
            #  *******************************************
            #  *     Page is full - start a new page
            #  *******************************************
            computeNewPage ()

    #  ***************************************************
    #  *   Start Here:  Examine every line of file
    #  ***************************************************

    for line in file:
        cl.lineno += 1
        line       = expandTabs (line).rstrip ()
        #  *           generate line text to print
        if options.number:
            text = ('%4d: ' % cl.lineno) + line
        else:
            text = line

        #  *      check for and deal with line wrapping
        llen  =  len (text)
        if llen > maxcpl:
            cl.wrapped += 1
            while len (text) > maxcpl:
                cnt  = maxcpl - 1
                this = text[0:cnt]      # before wrap
                that = text[cnt:]       # after wrap
                computeNewLine ()
                # ****************************************
                # *   produce continuation line text
                # ****************************************
                if options.number:
                    text = "123456" + that
                else:
                    text = that
        #  ***********************************************
        #  *   line didn't wrap or last wrapped segment
        #  ***********************************************
        computeNewLine ()

    #  ***************************************************
    #  *
    #  *  Finished processing all lines: return totals
    #  *
    #  ***************************************************

    if options.verbose:
        print ("%s: computeTotals lines=%d, linepos=%d, pages=%d, subpages=%d" %
               (MyName, cl.lineno, cl.linepos, 1 + cl.pageno, 1 + cl.subpageno))

    return (cl.pageno + 1, cl.subpageno + 1)


#   **************************************************
#   *
#   *   Setup command line parser
#   *
#   **************************************************

parser = argparse.ArgumentParser(

    prog        = MyName,
    description = 'Prints unicode file or stdin to pdf file.'

)

parser.add_argument ('-o',
		     help    = 'Set output PDF file path',
		     default = '')

parser.add_argument ('-overwrite',
		     help    = 'Allow PDF file to be overwritten.',
		     default = 0,
		     action  = 'count')

parser.add_argument ('-paper',
		     help    = 'Change the default paper size.',
		     default = 'letter')

parser.add_argument ('-portrait',
                     help    = 'View page in portrait mode.',
                     action  = 'count',
                     default = 0)

parser.add_argument ('-landscape',
                     help    = 'View page in landscape mode.',
                     action  = 'count',
                     default = 0)

parser.add_argument ('-2up',
                     help    = 'Print two pages per page in landscape mode.',
                     dest    = 'twoup',
                     action  = 'count',
                     default = 0)

parser.add_argument ('-tabs',
                     help    = 'Provide tab stop settings for input file',
                     default = 8)

parser.add_argument ('-number',
		     help    = 'Number output lines.',
		     action  = 'count',
		     default = 0)

parser.add_argument ('-borders',
                     help    = 'Draw borders around page.',
                     action  = 'store_true')

parser.add_argument ('-noborders',
		     help    = 'Do not draw borders around page.',
                     dest    = 'borders',
		     action  = 'store_false')

parser.set_defaults (borders = True)

parser.add_argument ('-headings',
                     help    = 'Print page headings.',
                     action  = 'store_true')

parser.add_argument ('-noheadings',
		     help    = 'Do not include page headings.',
                     dest    = 'headings',
		     action  = 'store_false')

parser.set_defaults (headings= True)

parser.add_argument ('-font',
		     help    = 'Name of font used to display file.',
		     default = 'APLUA')

parser.add_argument ('-fs',
		     help    = 'Size in points for font.',
		     type    = int,
		     default = 0)

parser.add_argument ('-lineskip',
		     help    = 'Additional line skip in points.',
		     type    = int,
		     default = 0)

parser.add_argument ('-verbose', '-v',
		     help    = 'Display additional information',
		     default = 0,
		     action  = 'count')

parser.add_argument ('filename',
		     help    = 'File to be printed.')


#   **************************************************
#   *
#   *   Parse command line and display results if -v
#   *
#   **************************************************

options = parser.parse_args ()

if options.verbose > 0:
    printoptions (options)


#   **************************************************
#   *
#   *    Verify -paper settings
#   *
#   **************************************************

initialPageSetting ()

page = papersizes[options.paper]


#   **************************************************
#   *
#   *  Initialize font name
#   *
#   *  Default font size to 5 point if -2up, otherwise 8 points
#   *
#   *  Switch to landscape mode if -2up or -landscape
#   *
#   **************************************************

fontname = options.font

if 0 != options.fs:
    fontsize   = options.fs
else:
    if options.twoup and 0 == options.fs:
        fontsize = 5
    else:
        fontsize = 8


if options.landscape or options.twoup:
    page = ( page[1], page[0] )
    if options.verbose:
        print "%s:  generating landscape output" % MyName


#   **************************************************
#   *
#   *   Setup file names:
#   *
#   *     - output file (PDF file)
#   *
#   *     - basename and fullname of input file
#   *
#   *     -  Open and read input file
#   *
#   **************************************************

setOutputFile (parser, options)

filename = os.path.expanduser (options.filename)
basename = os.path.basename   (options.filename)
fullname = os.path.abspath    (options.filename)


if options.verbose > 0:
    print "File Name"
    print "=============================="
    print "Output file = '%s'" % options.o
    print "Base Name   = '%s'" % basename
    print "Full Name   = '%s'" % fullname


if 0 == os.path.exists (filename):
    fatalerror (parser, "File '%s' does not exist" % options.filename)

try:
    fd = codecs.open (filename, encoding='utf-8')
except IOError as ei:
    fatalerror (parser, "Open failed: %s" % ei)
except OSError as ei:
    fatalerror (parser, "Open failed: %s" % ei)

try:
    file = fd.read ().splitlines ()
except OSError as ei:
    fatalerror (parser, "Read failed: %s" % ei)
except IOError as ei:
    fatalerror (parser, "Read failed: %s" % ei)


#   **************************************************
#   *
#   *     Initialize cairo output PDF
#   *
#   **************************************************


surface    = cairo.PDFSurface (options.o, page[0], page[1])
context    = cairo.Context (surface)
font       = pango.FontDescription(fontname + ' %d' % fontsize)

if options.verbose > 2:
    print "Font Family = '%s'" % font.get_family ()

if options.verbose > 0:
    printFont (font)


#   **************************************************
#   *
#   *              set white page background
#   *
#   **************************************************

context.rectangle (0, 0, page[0], page[1])
context.set_source_rgb (1, 1, 1)             # White
context.fill ()


#   ***************************************************
#   *
#   *  Create and initialize pango cairo context
#   *
#   ***************************************************

pccontext = pangocairo.CairoContext(context)
pccontext.set_antialias(cairo.ANTIALIAS_SUBPIXEL)

#   **************************************************
#   *
#   *  Create layout
#   *
#   *  Initialize font and font information
#   *
#   *  Initialize character and line spacing information
#   *
#   **************************************************

if options.twoup:
    #
    #  +-----------------------+ +---------------------------------------+
    #  |  (lmargin, umargin)   | |(lmargin + maxcolpos + 14, umargin)    |
    #  |          |            | |                         |             |
    #  |          |            | |                         |             |
    #  |          |            | |                         |             |
    #  |          |            | |                         |             |
    #  |          |            | |                         |             |
    #  |         \ /           | |                        \ /            |
    #  |  (lmargin, maxlinepos)| |(lmargin + maxcolpos + 14, maxlinepos) |
    #  +-----------------------+ +---------------------------------------+
    #
    maxcolpos = (page[0] - (lmargin * 2) - pg2upsep) / 2
else:
    maxcolpos =  page[0] - (lmargin * 2)

# ***********************************************************************
# *
# *   create pango-cairo context and initialize font
# *
# ***********************************************************************

layout      = pccontext.create_layout()
layout.set_font_description(font)

# ***********************************************************************
# *
# *   finalize page layout
# *
# ***********************************************************************

lineskip    = 0
maxcpl      = getMaxCPL (layout)
lineskip   += options.lineskip

maxlinepos  = umargin + int ((page[1] - (2 * umargin)) / lineskip) * lineskip
maxlinepos  = int (maxlinepos)
maxlpp      = int ((maxlinepos - umargin)/ lineskip)

if maxlpp < 8:
    fatalerror (options, "Font size too large")


# **************************************************
# *
# *  Create heading line if generating headings
# *
# **************************************************

if options.headings:
    heading = createHeading (maxcpl, datentime, basename)


# *******************************************************
# *
# *  Compute total number of pages/subpages in file
# *
# *******************************************************

totalpages, totalsubpages = computeTotals (lineskip, maxcpl, maxlinepos, file)

if options.verbose > 0:
    displayLayout ()


# *********************************************************
# *
# *  Translate coordinates to lmargin in and umargin down
# *
# *********************************************************

context.translate (lmargin, umargin)


# **************************************************
# *
# *           Print each line of file
# *
# **************************************************

for line in file:
    lineno  += 1
    line     = expandTabs (line, options.tabs).rstrip ()
    if options.number:
        ltext = ('%4d: ' % lineno) + line
    else:
        ltext = line

    llen   = len (ltext)

    if llen > maxcpl:
        wrapped += 1

        if options.verbose > 0:
            print "**** Wrapped line=%d, len=%d, maxcpl=%d"%(lineno,llen,maxcpl)
	    if options.verbose > 1:
	        print text[0:maxcpl]

        while len (ltext) > maxcpl:
       	    cnt  = maxcpl - 1
	    this = ltext[0:cnt]
	    that = ltext[cnt:]
	    newOutputLine (layout, context, pccontext, this + "\\")

	    if options.number:
	        ltext = "      " + that
	    else:
	        ltext = that

    newOutputLine (layout, context, pccontext, ltext)

finishOutputPage (layout, context, pccontext)


# *******************************************************
# *
# *               Print summary
# *
# *******************************************************

wstr  = ""  if  0 == wrapped    else  (" (%d wrapped) "   %  wrapped)
upstr = ""  if  0 == subpageno  else  (" on %d subpages"  %  (subpageno + 1))

print "%d lines output%s%s on %d pages" % (lineno, wstr, upstr, pageno-1)
